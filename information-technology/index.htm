<h1 class="title">Information Technology Environment â€” Ember</h1>

<p class="breadcrumbs">Page location:
    <span><a href="/components.htm">Core project components</a></span>
</p>

<h2>Introduction</h2>
<p>This section documents the Ember computing environment: a centralized append-only information store, a computer operating system integrated with that information store, and related specifications.</p>

<h2>Overview</h2>
<p>The computing environment will consist of the following components:</p>
<ul>
    <li>Development principles, describing the process to use for creating the computing environment</li>
    <li>Data formats: Specifications of the data formats used by the computing environment.</li>
    <li>Client app</li>
    <li>Server apps:
        <ul>
            <li>Public-facing API</li>
            <li>Search engine</li>
            <li>Storage backend</li>
        </ul>
    </li>
</ul>

<h2>Development principles</h2>
<h3>Prerequisites for code to be added to the repository</h3>
<ul>
    <li>Code must be readable and documented.</li>
    <li>Code must not cause or have failing tests.</li>
    <li>Code should include thorough automatic test coverage.</li>
    <li>Code must address a deviation from the current specification (bug, missing feature, <span class="foreign-text">etc.</span>), and may not contain other code.</li>
</ul>
<h3>How issues should be prioritised</h3>
<p>Ordered from highest priority to lowest priority</p>
<ol>
    <li>Security vulnerabilities</li>
    <li>Functional regressions</li>
    <li>Incorrect results</li>
    <li>Crashes and similar critical usability issues</li>
    <li>Slow code with a significant impact on usability</li>
    <li>Aesthetic regressions</li>
    <li>Minor usability issues</li>
    <li>Slow code with a moderate impact on usability</li>
    <li>Missing features</li>
</ol>

<h2>Data formats</h2>

<h3>Ember Language</h3>
<p>Objective: Develop a machine-readable language that can be source-to-source translated into other languages. A NQP translator should be the current development priority, followed by Qt and JavaScript translators.</p>
<p>Ember Language programs may optionally declare a non-default language profile to use: Core, Basic, and Dangerous (the default is "Standard"). Core and Basic both restrict the program to a subset of the language. The Basic language interpreter is written using the Core subset of the language, and provides useful shortcuts to use in the development of the interpreter for the Standard profile. The Default language interpreter is written using the Basic subset of the language. The Dangerous profile allows using language features which are probably a bad idea to use, but may be needed in some cases.</p>
<p>Ember Language programs can optionally run in one of three modes: Document, Terminal, and Web; these modes set up a basic environment for the program for running with a graphical raster display output, with a character-based terminal output, and as a Web server, respectively.</p>
<h4>Specification</h4>
<h5>Standard syntax (Ember Language source files, terminal: .em/.emc/.emb/.emd; document: .ed/.edc/.edb/.edd; Web: .ew/.ewc/.ewb/.ewd)</h5>
<p>Ember Language source files are a subset of ASCII text files, with lines delimited by 0x3B0A (semicolon+line feed). Bytes 0x00 through 0x09, 0x0B through 0x1F, and 0x7F through 0xFF (all ranges inclusive) are invalid. (0x0A may not be used except as a line separator.) File must end with 0x0A.</p>
<p>Text after a "#" on a line are comments.</p>
<h5>Ember Language intermediate code, .emi</h5>
<p>This is similar to standard syntax, but where shorthand notations are all expanded into the equivalent Dc sequences.</p>
<h5>Ember Language sequence files, .ems</h5>
<p>A comma-separated list of Dc numbers.</p>
<h5>Ember Language Dc documents, .edc</h5>
<p>Documents stored using a format similar to the DCE file format.</p>
<h5>Ember Record Documents, .emr</h5>
<p>This is a special format that can only represent a subset of Ember Documents, used for records storage in the Ember cloud.</p>
<p>Routines with some dangerous properties must be labeled accordingly, as follows:
    <dl>
        <dt>cs!</dt><dd><span class="important-letter">C</span>hangeable routine <span class="important-letter">s</span>ignature (subtypes don't need to use this routine's signature when overriding it.)</dd>
        <dt>nd!</dt><dd><span class="important-letter">N</span>on-<span class="important-letter">d</span>eterministic</dd>
    </dl>
</p>
<h5>Object hierarchy</h5>
<p>All objects are addressed through a hierarchy:
<dl>
    <dt>lang</dt><dd>Basic language Objects and Routines (automatically included)</dd>
    <dt>system</dt><dd>Objects and Routines related to the Ember environment</dd>
    <dt>math</dt><dd>Objects and Routines related to mathematics</dd>
</dl>
</p>

<h5>Operators</h5>

<h6>One-argument</h6>

<dl>
    <dt>C Void:print</dt><dd>print: lang.print($right)</dd>
</dl>

<h6>Two-argument</h6>

<dl>
    <dt>C Boolean:=</dt><dd>comparison: if left is exactly equal to right, evaluates to true, otherwise false: lang.compare($left,$right)</dd>
    <dt>C Boolean:|</dt><dd>exclusive or: lang.xor($left,$right)</dd>
    <dt>C Boolean:||</dt><dd>inclusive or: lang.ior($left,$right)</dd>
    <dt>C Void:&lt;-</dt><dd>assignment: lang.set(lang.trait($left),$right)</dd>
    <dt>C Any:otherwise</dt><dd>simple exception handling: lang.otherwise($left,$right)</dd>
</dl>

<h5>Types</h5>
<p>Types have CamelCase names beginning with an uppercase letter.</p>
    <h6>C Type</h6>
    <dl>
        <dt>Traits</dt><dd>C Type$type</dd>
        <dt>Routines</dt><dd>C cs!this.$type:new(FuzzyList$params) { lang.new(this) }</dd>
    </dl>

    <h6>C Routine</h6>
    <dl>
        <dt>Traits</dt><dd>
            <ul>
                <li>C String$code</li>
                <li>C (Null|Routine)$onExit</li>
            </ul></dd>
        <dt>Routines</dt><dd><ul>
            <li>C Any:run(FuzzyList$params) { lang.run(this,lang.cast($params,List,"return")) }</li>
            <li>C Boolean:compare(Any$object) { /* return true if this object is identical to $object */ }</li>
        </ul></dd>
    </dl>

    <h6>C List</h6>
    <dl>
        <dt>Traits</dt><dd>
            <ul>
                <li>B List{set this.$allowedTypes=lang.new(List).add(Type)}$allowedTypes: List of allowed types that can be put in this list</li>
                <li>C Natural$last: last valid index</li>
                <li>C Natural$count: number of entries</li>
                <li>B (Null|Natural)$entryLimit: number of entries that the list may hold; defaults to Null (meaning unlimited)</li>
                <li>S (Null|Natural)$indexLimit: maximum index the list may use; defaults to Null (meaning unlimited)</li>
            </ul></dd>
        <dt>Routines</dt><dd>
            <ul>
                <li>B Void:add(String$value|List$value) { this.insert(this.last()+1) }</li>
                <li>B Void:set(Natural$index,(String$value|List$value)) { lang.set(this.record($index),$value) }</li>
                <li>B Any:get(Natural$index) { lang.get(this.record($index)) }</li>
                <li>C Reference:record(Natural$index) { lang.getListEntry(this,$index) }</li>
                <li>B Void:insert(Natural$index,(String$value|List$value)): insert $value at $index, moving the current $index and following items ahead by $value.count() if it's a list, and by 1 if it's a string</li>
            </ul></dd>
    </dl>

    <h6>C FuzzyList (inherits from List)</h6>
    <p>When a FuzzyList is used in a list, its contents are appended to the list, and it is deconstructed. When a FuzzyList is used in the declaration of the parameters of a Routine, its first elements, starting from 0, are set to the values of the parameters passed to the Routine from its position onwards (so, for example, if the parameters declared are Natural$a,Natural$b,FuzzyList{ lang.set(lang.trait(this.entryLimit),2) }$c,Natural$d,Natural$e and it gets called with 2,3,4,5,6,7,8, then that's an error because there's no place to put 6 (the 5th parameter) (but if the entryLimit weren't set, a=2,b=3,c=(4,5,6),d=7,e=8), and if it gets called with 2,3,4,5,6,7, a=2,b=3,c=(4,5),d=6,e=7).</p>

    <h6>C Resource</h6>
    <dl>
        <dt>Traits</dt><dd></dd>
        <dt>Routines</dt><dd></dd>
    </dl>

<h5>System object: Traits</h5>
<p>Traits have camelCase names beginning with a lowercase letter.</p>
<dl>
    <dt>C nd!List[Resource]:system.resources</dt><dd>List of resources (I/O, etc) available.</dd>
    <dt>C nd!String:system.implementation</dt><dd>Description of the language backend.</dd>
</dl>

<h5>System object: Routines</h5>
<p>Routines have camelCase names beginning with a lowercase letter, and have parameters; they also sometimes have an object specification to allow for overloading (specified like <code>routine:$object { ... }</code>; to call that routine, pass it that object again; note that in most situations $object would be a Type; using routine overloading with other types of objects is only permitted in the Dangerous language profile).</p>
<h6>C $type:lang.new(Type$type)</h6>
<dl>
    <dt>Return value</dt><dd>A new object of the type passed to it</dd>
    <dt>Exceptions thrown</dt><dd>(none additional)</dd>
    <dt>Notes</dt><dd>Determinism depends on the type's constructor, if any.</dd>
</dl>
<h6>C Void:lang.run(Routine$routine,List$params)</h6>
<dl>
    <dt>Exceptions thrown</dt><dd>!routineSyntaxError, !parameterNumberMismatch, !parameterTypeMismatch</dd>
    <dt>Notes</dt><dd>Determinism depends on String:$routine.code.</dd>
</dl>
<h6>C (Void|$type):lang.cast(Any$object,Type$type,(|String$return))</h6>
<dl>
    <dt>Return value</dt><dd>None, unless $return="return" in which case it returns an object of type $type</dd>
    <dt>Exceptions thrown</dt><dd>!incompatibleTypeError</dd>
    <dt>Notes</dt><dd>If $return="return", determinism depends on types of objects (specifically, on value of String:$object.cast:$type.code).</dd>
</dl>
<h6>C (Void|$trait.type):lang.set(Reference$trait,Any$value,(|String$return))</h6>
<dl>
    <dt>Return value</dt><dd>None, unless $return="return" in which case it returns an object of type $trait.type</dd>
    <dt>Exceptions thrown</dt><dd>!targetTypeMismatch</dd>
    <dt>Notes</dt><dd>If $return="return", determinism depends on $value.</dd>
</dl>
<h6>C $trait.type:lang.get(Reference$trait)</h6>
<dl>
    <dt>Return value</dt><dd>An object of type $trait.type</dd>
    <dt>Exceptions thrown</dt><dd>(none additional)</dd>
    <dt>Notes</dt><dd>Determinism depends on $trait.</dd>
</dl>
<h6>C Reference:lang.trait(Any$object)</h6>
<dl>
    <dt>Return value</dt><dd>A reference to the object passed to it</dd>
    <dt>Exceptions thrown</dt><dd>(none additional)</dd>
    <dt>Notes</dt><dd>(none)</dd>
</dl>
<h6>C Boolean:lang.and(Boolean$left,Boolean$right)</h6>
<dl>
    <dt>Return value</dt><dd>Logical and: $left and $right</dd>
    <dt>Exceptions thrown</dt><dd>(none additional)</dd>
    <dt>Notes</dt><dd>(none)</dd>
</dl>
<h6>C Boolean:lang.xor(Boolean$left,Boolean$right)</h6>
<dl>
    <dt>Return value</dt><dd>Exclusive or: $left xor $right</dd>
    <dt>Exceptions thrown</dt><dd>(none additional)</dd>
    <dt>Notes</dt><dd>(none)</dd>
</dl>
<h6>C Boolean:lang.ior(Boolean$left,Boolean$right)</h6>
<dl>
    <dt>Return value</dt><dd>Inclusive or: $left or $right</dd>
    <dt>Exceptions thrown</dt><dd>(none additional)</dd>
    <dt>Notes</dt><dd>(none)</dd>
</dl>
<h6>C Boolean:lang.compare(Any$left,Any$right)</h6>
<dl>
    <dt>Return value</dt><dd>lang.and($left.compare($right),$right.compare($left))</dd>
    <dt>Exceptions thrown</dt><dd>(inherit from $left.compare and $right.compare)</dd>
    <dt>Notes</dt><dd>(none)</dd>
</dl>
<h6>S Any:lang.otherwise(Routine$left,Routine$right)</h6>
<dl>
    <dt>Return value</dt><dd>try { return $left }; except { return $right }</dd>
    <dt>Exceptions thrown</dt><dd>(inherit from $left and $right)</dd>
    <dt>Notes</dt><dd>(none)</dd>
</dl>
<h6>C nd!Void:lang.print(String$string)</h6>
<dl>
    <dt>Exceptions thrown</dt><dd>!noStringOutputResourceAvailable</dd>
    <dt>Notes</dt><dd>(none)</dd>
</dl>
<h6>C nd!Void:lang.sprint(Sstring$string)</h6>
<dl>
    <dt>Exceptions thrown</dt><dd>!noStringOutputResourceAvailable</dd>
    <dt>Notes</dt><dd>(none)</dd>
</dl>
